# Reactチュートリアル

https://beta.reactjs.org/learn

めちゃくちゃいい。
状態管理や宣言的UIの説明に関しては、普通にVueとかにも有用な知見が多い。

DeepLで自然に訳しながら読める（DeepLすごいね）。

## 疑問とか

- PresenterやView Modelをコンポーネント外部に作ることはできないか？
  - Vueだとdataオプションに持たせた複雑な状態を、内部でクラスメソッド経由で変更し、算出プロパティでViewに伝搬させていた、みたいなことがしたい
  - useState Hookのセッターでやろうとすると、オブジェクト全体をコピーし直さないといけない気がするが、コストが高すぎる気がする？
  - [ここ](https://beta.reactjs.org/learn/choosing-the-state-structure)に答えが書いてある気がする？
  - まぁ、仮にこれまで自分がやってきたような雑なオブジェクトのmutationが許されないとしても、丁寧に別のUI用の状態レイヤを設計すれば、大抵の問題は解決する（気がする？）
- render, commitの概念がちょっとピンと来てないかも
  - `Trigger -> Render -> Commit`
  - ブラウザに描画することを 'browser paint' と読んでいる
- 「"レンダリング" とは、Reactがあなたのコンポーネントを呼び出すことであり、それは関数である。その関数から返されるJSXは、UIの時間的なスナップショットのようなものです。そのprops、イベントハンドラ、ローカル変数はすべて、レンダリング時の状態を用いて計算されたものです。」
  - `execute function -> calculate snapshot -> update DOM tree`
  - [このページ](https://beta.reactjs.org/learn/state-as-a-snapshot)で説明される内容は、最初は混乱してしまうかもしれないので、重要だと思う。
  - [次のページ](https://beta.reactjs.org/learn/queueing-a-series-of-state-updates)も同様に大事
    - updater関数というのを渡すと以前の値を使えるようになる
- Immerというのは、オブジェクトの一部をmutationすることでも、ReactにUIの変更を伝えさせるライブラリ、ぐらいのイメージだろうか？
  - おそらくは全く不正確だが、とりあえずそれぐらいに思っておく。
  - これもHookの一種なのかも？
  - オブジェクトだけではんく、配列も対象とできる
- Reactは算出プロパティというのを考えなくて良い
  - useStateから返ってくる状態から、普通のJSオブジェクトを生成して、それをUIに渡せば良い
- [状態管理のページ](https://beta.reactjs.org/learn/managing-state)は勉強になることも多いが、やはりちょっとむずかしい。
  - lifting state up: 状態の引き上げ
  - ReducerとContextで複雑な画面コンポーネントを作る
- 命令形UI, imperative UI
  - どこへ向かっているのかわからない、ただ与えられたコマンドに従うだけ
  - 複雑なシステムでは辛くなるので、Reactはこの問題を解決するために生まれた。
- 宣言型プログラミングとは、UIを細かく管理する（命令型）のではなく、視覚的な状態ごとにUIを記述することです。
- 宣言的UIの考え方
  - コンポーネントのさまざまなビジュアルステートを特定する
  - 何が状態を変化させるトリガーになるかを判断する
  - メモリ上の状態をuseStateで表現する
  - 必要でない状態変数を削除する
  - 状態を設定するイベントハンドラを接続する
- **コンポーネントが様々な視覚状態を持っているとき、ページにそれを全パターンレンダリングしてみると良い。**
  - **このようなページのことを "storybooks" と呼ぶ！**
- UMLのステートマシン図を書くことは、Reactのような宣言的UIを実装する際に重要になりそう。
  - [ステートマシン図＆状態遷移表チュートリアル](https://www.changevision.co/tutorial-statemachine-japanese.html)
- 不要な状態を削るための3つの質問
  - その状態は矛盾を引き起こしませんか？
  - 他の状態から導くことはできませんか（例えば、あるbooleanの否定などで）？
- 状態の構造化の原則
  - **関連する状態をグループ化する。**常に2つ以上の状態変数を同時に更新する場合は、それらを1つの状態変数に統合することを検討してください。
  - **状態の矛盾を避ける。**状態のいくつかの部分が互いに矛盾して「不一致」になる可能性があるような構造になっていると、ミスを犯す余地を残すことになります。これを避けるようにしましょう。
  - **冗長な状態を避ける。**レンダリング中にコンポーネントのプロップまたは既存のステート変数から何らかの情報を計算できる場合、その情報をそのコンポーネントのステートに入れるべきではありません。
  - **状態の重複を避ける。**複数の状態変数の間や、ネストされたオブジェクトの中で同じデータが重複していると、それらを同期させることが難しくなります。できる限り重複を減らしましょう。
    - 例えば何かを選択したときは、選択されたオブジェクトのポインタを状態とするのではなく、選択されたオブジェクトのID（配列インデックス、もしくはidentity値）を状態とするのが良い。
  - **深くネストされた状態を避ける。**深く階層化された状態は、更新するのにあまり便利ではありません。可能な限り、状態をフラットに構成することが望ましい。
    - 素直な木構造をやめて、シンプルでフラットな配列にデータ構造を変える、など。
    - このノウハウは結構難しいはずで、経験値が求められそう。
- 状態の構造化が重要な理由。
  - これらの原則の背後にある目標は、ミスを発生させずに状態を簡単に更新できるようにすることです。
  - これは、データベースエンジニアが、バグの可能性を減らすためにデータベース構造を「正規化」するのと似ています。
- 状態のlift upについて
  - Vueではevent upで親コンポーネントにイベントを伝搬させると思うが、Reactではprop経由でもらったstateのsetterを直接実行する
  - なれるまで時間がかかりそう
- DOMに対応するようにCCSOMという概念があるのは初めて知った。
  - [CSSオブジェクトモデル（MDN）](https://developer.mozilla.org/ja/docs/Web/API/CSS_Object_Model)
- [このページ]*(https://beta.reactjs.org/learn/preserving-and-resetting-state)の内容はReact独特かもしれない
  - Reactで重要なのは、JSXマークアップではなく、UIツリー内の位置であることを忘れないでください。
    - 「これは保存されるんだろうか？破棄されるんだろうか？」というのは、最初のうちはよく悩むことになりそう。
  - 経験則として、再レンダリング間で状態を保持したい場合は、レンダリングごとにツリーの構造を「一致」させる必要があります。構造が異なると、React はツリーからコンポーネントを削除するときに状態を破棄するため、状態が破棄されます。
- [TODOリストっぽいサンプル](https://beta.reactjs.org/learn/extracting-state-logic-into-a-reducer#consolidate-state-logic-with-a-reducer)
  - reducerのよいサンプルと言えるかもしれない
- reducerはコンポーネント外に置かれるもの（reducer≒dispatch関数、多分）
  - なんとなく、Vuexっぽく見える
    - 状態自体はコンポーネント内に持つので、コンポーネントローカルのVuex、というイメージ
    - 状態を変更する関数が分離されて一箇所にまとまっているので、ログを追加したり変更をトレースするのに良さそう。
  - dispatch関数に渡されるオブジェクトのことを「アクション」と呼ぶ
    - dispatch: 送る
  - dispatch関数の中では、if文ではなくswitch文で分岐させるのが慣例となっている
  - reducerの名前の由来は、配列のreduceメソッドから
    - reduceに渡す関数は「reducer」と呼ばれる。これまでの結果と現在のアイテムを受け取り、次の結果を返します。Reactのreducerも同じ考え方の例で、これまでの状態とアクションを受け取って、次の状態を返します。このように、時間をかけてアクションを蓄積し、ステートにしていく。
  - useStateよりも常にuseReducerが優れている、というわけではないが、個人的にreducer関数を純粋関数として分けられることによるテスタビリティはとても魅力的。
- [Context](https://beta.reactjs.org/learn/passing-data-deeply-with-context)
  - prop drillinを防ぐもの、ということからも、こちらのほうがVuexに近そう
  - コンテキストは、親コンポーネントがその下のツリー全体にデータを提供することを可能にします。
    - Vuexっぽい、とはいっても、アプリ全体の状態ではなく、あくまでも「ある親コンポーネントに保持した状態」ということは変わらない
    - 子供から親の状態を要求できる機構、と言えそう
  - propから読んでいたオブジェクトを、useContext Hookから呼ぶように変える（子コンポーネント）
  - 注意深く読まないとContextが使われているかどうか、どう使われているかがわからない気がするので、なるべく使いたくはなさそう
  - **コンテキストの仕組みは、CSSのプロパティの継承を思い起こさせるかもしれない。**CSS では、<div> に color: blue を指定すると、その中にある DOM ノードは、どんなに深くても、他の DOM ノードが color: green で上書きしない限り、その色を引き継ぎます。同様に、React では、上からのコンテキストを上書きする唯一の方法は、子ノードを別の値を持つコンテキスト プロバイダにラップすることです。
    - CSSでは、colorとbackground-colorのような異なるプロパティは、互いに上書きされません。<div>の色をすべて赤に設定しても、background-colorには影響しません。同様に、異なるReactのコンテキストは互いにオーバーライドされません。createContext()で作成したそれぞれのコンテキストは、他のコンテキストとは完全に分離しており、その特定のコンテキストを使用したり提供したりするコンポーネントを結びつけています。ひとつのコンポーネントが多くの異なるコンテキストを使用したり提供したりしても、問題はありません。




